{
  "version": 3,
  "sources": ["../../svelte/src/compiler/phases/1-parse/utils/names.js", "../../svelte/src/internal/shared/validate.js"],
  "sourcesContent": ["export const reserved = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\nconst void_element_names = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/** @param {string} name */\nexport function is_void(name) {\n\treturn void_element_names.includes(name) || name.toLowerCase() === '!doctype';\n}\n", "import { is_void } from '../../compiler/phases/1-parse/utils/names.js';\n\nconst snippet_symbol = Symbol.for('svelte.snippet');\n\n/**\n * @param {any} fn\n */\nexport function add_snippet_symbol(fn) {\n\tfn[snippet_symbol] = true;\n\treturn fn;\n}\n\n/**\n * Validate that the function handed to `{@render ...}` is a snippet function, and not some other kind of function.\n * @param {any} snippet_fn\n */\nexport function validate_snippet(snippet_fn) {\n\tif (snippet_fn && snippet_fn[snippet_symbol] !== true) {\n\t\tthrow new Error(\n\t\t\t'The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. ' +\n\t\t\t\t'If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`.'\n\t\t);\n\t}\n\treturn snippet_fn;\n}\n\n/**\n * Validate that the function behind `<Component />` isn't a snippet.\n * @param {any} component_fn\n */\nexport function validate_component(component_fn) {\n\tif (component_fn?.[snippet_symbol] === true) {\n\t\tthrow new Error('A snippet must be rendered with `{@render ...}`');\n\t}\n\treturn component_fn;\n}\n\n/**\n * @param {() => string} tag_fn\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag_fn) {\n\tconst tag = tag_fn();\n\tif (tag && is_void(tag)) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n\t}\n}\n\n/** @param {() => unknown} tag_fn */\nexport function validate_dynamic_element_tag(tag_fn) {\n\tconst tag = tag_fn();\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\tthrow new Error('<svelte:element> expects \"this\" attribute to be a string.');\n\t}\n}\n"],
  "mappings": ";AAmDA,IAAM,qBAAqB;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAGO,SAAS,QAAQ,MAAM;AAC7B,SAAO,mBAAmB,SAAS,IAAI,KAAK,KAAK,YAAY,MAAM;AACpE;;;ACvEA,IAAM,iBAAiB,OAAO,IAAI,gBAAgB;AAK3C,SAAS,mBAAmB,IAAI;AACtC,KAAG,cAAc,IAAI;AACrB,SAAO;AACR;AAMO,SAAS,iBAAiB,YAAY;AAC5C,MAAI,cAAc,WAAW,cAAc,MAAM,MAAM;AACtD,UAAM,IAAI;AAAA,MACT;AAAA,IAED;AAAA,EACD;AACA,SAAO;AACR;AAMO,SAAS,mBAAmB,cAAc;AAChD,OAAI,6CAAe,qBAAoB,MAAM;AAC5C,UAAM,IAAI,MAAM,iDAAiD;AAAA,EAClE;AACA,SAAO;AACR;AAMO,SAAS,8BAA8B,QAAQ;AACrD,QAAM,MAAM,OAAO;AACnB,MAAI,OAAO,QAAQ,GAAG,GAAG;AAExB,YAAQ,KAAK,yBAAyB,GAAG,6CAA6C;AAAA,EACvF;AACD;AAGO,SAAS,6BAA6B,QAAQ;AACpD,QAAM,MAAM,OAAO;AACnB,QAAM,YAAY,OAAO,QAAQ;AACjC,MAAI,OAAO,CAAC,WAAW;AACtB,UAAM,IAAI,MAAM,2DAA2D;AAAA,EAC5E;AACD;",
  "names": []
}
