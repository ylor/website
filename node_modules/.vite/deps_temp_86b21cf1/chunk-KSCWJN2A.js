import {
  HYDRATION_END,
  HYDRATION_START,
  PassiveDelegatedEvents,
  UNINITIALIZED
} from "./chunk-GYQYGFH2.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  run_all
} from "./chunk-EE3BKQPP.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-6WDZWUHI.js";

// node_modules/svelte/src/internal/client/utils.js
var is_array = Array.isArray;
var array_from = Array.from;
var object_keys = Object.keys;
var is_frozen = Object.isFrozen;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var map_prototype = Map.prototype;
var map_set_method = map_prototype.set;
var map_get_method = map_prototype.get;

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var UNOWNED = 1 << 7;
var CLEAN = 1 << 8;
var DIRTY = 1 << 9;
var MAYBE_DIRTY = 1 << 10;
var INERT = 1 << 11;
var DESTROYED = 1 << 12;
var IS_ELSEIF = 1 << 13;
var EFFECT_RAN = 1 << 14;
var STATE_SYMBOL = Symbol("$state");

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? (
    // eslint-disable-next-line eqeqeq
    b == b
  ) : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
function source(value) {
  const source2 = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    reactions: null,
    equals,
    v: value,
    version: 0
  };
  if (DEV) {
    source2.inspect = /* @__PURE__ */ new Set();
  }
  return source2;
}
function mutable_source(initial_value) {
  var _a;
  const s = source(initial_value);
  s.equals = safe_equals;
  if (current_component_context) {
    ((_a = current_component_context).d ?? (_a.d = [])).push(s);
  }
  return s;
}
function set(signal, value) {
  var initialized = signal.v !== UNINITIALIZED;
  if (!current_untracking && initialized && current_reaction !== null && is_runes() && (current_reaction.f & DERIVED) !== 0) {
    throw new Error(
      "ERR_SVELTE_UNSAFE_MUTATION" + (DEV ? `: Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.` : "")
    );
  }
  if (!signal.equals(value)) {
    signal.v = value;
    signal.version++;
    if (is_runes() && initialized && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0) {
      if (current_dependencies !== null && current_dependencies.includes(signal)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect);
      } else {
        if (current_untracked_writes === null) {
          set_current_untracked_writes([signal]);
        } else {
          current_untracked_writes.push(signal);
        }
      }
    }
    mark_reactions(signal, DIRTY, true);
    if (DEV) {
      if (is_batching_effect) {
        set_last_inspected_signal(
          /** @type {import('#client').ValueDebug} */
          signal
        );
      } else {
        for (
          const fn of
          /** @type {import('#client').ValueDebug} */
          signal.inspect
        )
          fn();
      }
    }
  }
  return value;
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html) {
  var elem = document.createElement("template");
  elem.innerHTML = html;
  return elem.content;
}
function remove(current) {
  if (is_array(current)) {
    for (var i = 0; i < current.length; i++) {
      var node = current[i];
      if (node.isConnected) {
        node.remove();
      }
    }
  } else if (current.isConnected) {
    current.remove();
  }
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var is_root = (type & ROOT_EFFECT) !== 0;
  var effect2 = {
    ctx: current_component_context,
    deps: null,
    dom: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : current_effect,
    prev: null,
    teardown: null,
    transitions: null
  };
  if (current_reaction !== null && !is_root) {
    push_effect(effect2, current_reaction);
  }
  if (sync) {
    var previously_flushing_effect = is_flushing_effect;
    try {
      set_is_flushing_effect(true);
      execute_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } finally {
      set_is_flushing_effect(previously_flushing_effect);
    }
  } else {
    schedule_effect(effect2);
  }
  return effect2;
}
function effect_active() {
  return current_effect ? (current_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 : false;
}
function user_effect(fn) {
  if (current_effect === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_EFFECT" + (DEV ? ": The Svelte $effect rune can only be used during component initialisation." : "")
    );
  }
  const defer = current_effect.f & RENDER_EFFECT && // TODO do we actually need this? removing them changes nothing
  current_component_context !== null && !current_component_context.m;
  if (defer) {
    const context = (
      /** @type {import('#client').ComponentContext} */
      current_component_context
    );
    (context.e ?? (context.e = [])).push(fn);
  } else {
    effect(fn);
  }
}
function effect_root(fn) {
  const effect2 = create_effect(ROOT_EFFECT, () => untrack(fn), true);
  return () => {
    destroy_effect(effect2);
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function render_effect(fn) {
  return create_effect(RENDER_EFFECT, fn, true);
}
function branch(fn) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true);
}
function destroy_effect(effect2) {
  var _a;
  destroy_effect_children(effect2);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  if (effect2.transitions) {
    for (const transition of effect2.transitions) {
      transition.stop();
    }
  }
  (_a = effect2.teardown) == null ? void 0 : _a.call(effect2);
  if (effect2.dom !== null) {
    remove(effect2.dom);
  }
  var parent = effect2.parent;
  if (parent !== null && (effect2.f & BRANCH_EFFECT) !== 0 && parent.first !== null) {
    var previous = effect2.prev;
    var next = effect2.next;
    if (previous !== null) {
      if (next !== null) {
        previous.next = next;
        next.prev = previous;
      } else {
        previous.next = null;
        parent.last = previous;
      }
    } else if (next !== null) {
      next.prev = null;
      parent.first = next;
    } else {
      parent.first = null;
      parent.last = null;
    }
  }
  effect2.first = effect2.last = effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.dom = effect2.deps = effect2.parent = // @ts-expect-error
  effect2.fn = null;
}

// node_modules/svelte/src/internal/client/dom/task.js
var is_task_queued = false;
var is_raf_queued = false;
var current_queued_tasks = [];
var current_raf_tasks = [];
function process_task() {
  is_task_queued = false;
  const tasks = current_queued_tasks.slice();
  current_queued_tasks = [];
  run_all(tasks);
}
function process_raf_task() {
  is_raf_queued = false;
  const tasks = current_raf_tasks.slice();
  current_raf_tasks = [];
  run_all(tasks);
}
function flush_tasks() {
  if (is_task_queued) {
    process_task();
  }
  if (is_raf_queued) {
    process_raf_task();
  }
}

// node_modules/svelte/src/internal/client/dev/ownership.js
var boundaries = {};
var chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
var firefox_pattern = /@(.+):(\d+):(\d+)$/;
function get_stack() {
  const stack = new Error().stack;
  if (!stack)
    return null;
  const entries = [];
  for (const line of stack.split("\n")) {
    let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);
    if (match) {
      entries.push({
        file: match[1],
        line: +match[2],
        column: +match[3]
      });
    }
  }
  return entries;
}
function get_component() {
  var _a;
  const stack = (_a = get_stack()) == null ? void 0 : _a.slice(4);
  if (!stack)
    return null;
  for (let i = 0; i < stack.length; i++) {
    const entry = stack[i];
    const modules = boundaries[entry.file];
    if (!modules) {
      if (i === 0)
        return null;
      continue;
    }
    for (const module of modules) {
      if (module.start.line < entry.line && module.end.line > entry.line) {
        return module.component;
      }
    }
  }
  return null;
}
function add_owner(object, owner) {
  untrack(() => {
    add_owner_to_object(object, owner);
  });
}
function add_owner_to_object(object, owner) {
  var _a;
  if (((_a = object == null ? void 0 : object[STATE_SYMBOL]) == null ? void 0 : _a.o) && !object[STATE_SYMBOL].o.has(owner)) {
    object[STATE_SYMBOL].o.add(owner);
    for (const key in object) {
      add_owner_to_object(object[key], owner);
    }
  }
}
function strip_owner(object) {
  untrack(() => {
    strip_owner_from_object(object);
  });
}
function strip_owner_from_object(object) {
  var _a;
  if ((_a = object == null ? void 0 : object[STATE_SYMBOL]) == null ? void 0 : _a.o) {
    object[STATE_SYMBOL].o = null;
    for (const key in object) {
      strip_owner(object[key]);
    }
  }
}
function check_ownership(owners) {
  const component = get_component();
  if (component && !owners.has(component)) {
    let original = [...owners][0];
    let message = (
      // @ts-expect-error
      original.filename !== component.filename ? (
        // @ts-expect-error
        `${component.filename} mutated a value owned by ${original.filename}. This is strongly discouraged`
      ) : "Mutating a value outside the component that created it is strongly discouraged"
    );
    console.warn(
      `${message}. Consider passing values to child components with \`bind:\`, or use a callback instead.`
    );
    console.trace();
  }
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var updating_derived = false;
function destroy_derived_children(signal) {
  destroy_effect_children(signal);
  var deriveds = signal.deriveds;
  if (deriveds !== null) {
    signal.deriveds = null;
    for (var i = 0; i < deriveds.length; i += 1) {
      destroy_derived(deriveds[i]);
    }
  }
}
function update_derived(derived, force_schedule) {
  var previous_updating_derived = updating_derived;
  updating_derived = true;
  destroy_derived_children(derived);
  var value = execute_reaction_fn(derived);
  updating_derived = previous_updating_derived;
  var status = (current_skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived, status);
  if (!derived.equals(value)) {
    derived.v = value;
    mark_reactions(derived, DIRTY, force_schedule);
    if (DEV && force_schedule) {
      for (
        var fn of
        /** @type {import('#client').DerivedDebug} */
        derived.inspect
      )
        fn();
    }
  }
}
function destroy_derived(signal) {
  destroy_derived_children(signal);
  remove_reactions(signal, 0);
  set_signal_status(signal, DESTROYED);
  signal.first = signal.last = signal.deps = signal.reactions = // @ts-expect-error `signal.fn` cannot be `null` while the signal is alive
  signal.fn = null;
}

// node_modules/svelte/src/internal/client/runtime.js
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var is_flushing_effect = false;
function set_is_flushing_effect(value) {
  is_flushing_effect = value;
}
var is_batching_effect = false;
var is_inspecting_signal = false;
var current_queued_root_effects = [];
var flush_count = 0;
var current_reaction = null;
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_untracked_writes = null;
function set_current_untracked_writes(value) {
  current_untracked_writes = value;
}
var last_inspected_signal = null;
function set_last_inspected_signal(signal) {
  last_inspected_signal = signal;
}
var current_untracking = false;
var current_skip_reaction = false;
var is_signals_recorded = false;
var captured_signals = /* @__PURE__ */ new Set();
var inspect_fn = null;
var inspect_captured_signals = [];
var current_component_context = null;
function is_runes() {
  return current_component_context !== null && current_component_context.r;
}
function batch_inspect(target, prop, receiver) {
  const value = Reflect.get(target, prop, receiver);
  return function() {
    const previously_batching_effect = is_batching_effect;
    is_batching_effect = true;
    try {
      return Reflect.apply(value, this, arguments);
    } finally {
      is_batching_effect = previously_batching_effect;
      if (last_inspected_signal !== null && !is_inspecting_signal) {
        is_inspecting_signal = true;
        try {
          for (const fn of last_inspected_signal.inspect) {
            fn();
          }
        } finally {
          is_inspecting_signal = false;
        }
        last_inspected_signal = null;
      }
    }
  };
}
function check_dirtiness(reaction) {
  var flags = reaction.f;
  if ((flags & DIRTY) !== 0) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      for (var i = 0; i < length; i++) {
        var dependency = dependencies[i];
        if (check_dirtiness(
          /** @type {import('#client').Derived} */
          dependency
        )) {
          update_derived(
            /** @type {import('#client').Derived} **/
            dependency,
            true
          );
          if ((reaction.f & DIRTY) !== 0) {
            return true;
          }
        }
        var is_unowned = (flags & UNOWNED) !== 0;
        var version = dependency.version;
        if (is_unowned && version > /** @type {import('#client').Derived} */
        reaction.version) {
          reaction.version = version;
          return true;
        }
      }
    }
    set_signal_status(reaction, CLEAN);
  }
  return false;
}
function execute_reaction_fn(signal) {
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_reaction = current_reaction;
  const previous_skip_reaction = current_skip_reaction;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('./types.js').Value[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_reaction = signal;
  current_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;
  current_untracking = false;
  try {
    let res = signal.fn();
    let dependencies = (
      /** @type {import('./types.js').Value<unknown>[]} **/
      signal.deps
    );
    if (current_dependencies !== null) {
      let i;
      if (dependencies !== null) {
        const deps_length = dependencies.length;
        const full_current_dependencies = current_dependencies_index === 0 ? current_dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const current_dep_length = full_current_dependencies.length;
        const full_current_dependencies_set = current_dep_length > 16 && deps_length - current_dependencies_index > 1 ? new Set(full_current_dependencies) : null;
        for (i = current_dependencies_index; i < deps_length; i++) {
          const dependency = dependencies[i];
          if (full_current_dependencies_set !== null ? !full_current_dependencies_set.has(dependency) : !full_current_dependencies.includes(dependency)) {
            remove_reaction(signal, dependency);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i = 0; i < current_dependencies.length; i++) {
          dependencies[current_dependencies_index + i] = current_dependencies[i];
        }
      } else {
        signal.deps = /** @type {import('./types.js').Value<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_reaction) {
        for (i = current_dependencies_index; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const reactions = dependency.reactions;
          if (reactions === null) {
            dependency.reactions = [signal];
          } else if (reactions[reactions.length - 1] !== signal) {
            reactions.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_reactions(signal, current_dependencies_index);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_reaction = previous_reaction;
    current_skip_reaction = previous_skip_reaction;
    current_untracking = previous_untracking;
  }
}
function remove_reaction(signal, dependency) {
  const reactions = dependency.reactions;
  let reactions_length = 0;
  if (reactions !== null) {
    reactions_length = reactions.length - 1;
    const index = reactions.indexOf(signal);
    if (index !== -1) {
      if (reactions_length === 0) {
        dependency.reactions = null;
      } else {
        reactions[index] = reactions[reactions_length];
        reactions.pop();
      }
    }
  }
  if (reactions_length === 0 && (dependency.f & UNOWNED) !== 0) {
    set_signal_status(dependency, DIRTY);
    remove_reactions(
      /** @type {import('./types.js').Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  const dependencies = signal.deps;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i;
    for (i = start_index; i < dependencies.length; i++) {
      const dependency = dependencies[i];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_reaction(signal, dependency);
      }
    }
  }
}
function destroy_effect_children(signal) {
  let effect2 = signal.first;
  signal.first = null;
  signal.last = null;
  var sibling;
  while (effect2 !== null) {
    sibling = effect2.next;
    destroy_effect(effect2);
    effect2 = sibling;
  }
}
function execute_effect(effect2) {
  var _a;
  var flags = effect2.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var component_context = effect2.ctx;
  var previous_effect = current_effect;
  var previous_component_context = current_component_context;
  current_effect = effect2;
  current_component_context = component_context;
  try {
    if ((flags & BLOCK_EFFECT) === 0) {
      destroy_effect_children(effect2);
    }
    (_a = effect2.teardown) == null ? void 0 : _a.call(effect2);
    var teardown = execute_reaction_fn(effect2);
    effect2.teardown = typeof teardown === "function" ? teardown : null;
  } finally {
    current_effect = previous_effect;
    current_component_context = previous_component_context;
  }
}
function infinite_loop_guard() {
  if (flush_count > 1e3) {
    flush_count = 0;
    throw new Error(
      "ERR_SVELTE_TOO_MANY_UPDATES" + (DEV ? ": Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops." : "")
    );
  }
  flush_count++;
}
function flush_queued_root_effects(root_effects) {
  for (var i = 0; i < root_effects.length; i++) {
    var signal = root_effects[i];
    flush_nested_effects(signal, RENDER_EFFECT | EFFECT);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0)
    return;
  infinite_loop_guard();
  for (var i = 0; i < length; i++) {
    var effect2 = effects[i];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect2)) {
      execute_effect(effect2);
    }
  }
}
function process_microtask() {
  is_micro_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_root_effects = current_queued_root_effects;
  current_queued_root_effects = [];
  flush_queued_root_effects(previous_queued_root_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
function schedule_effect(signal) {
  if (current_scheduler_mode === FLUSH_MICROTASK) {
    if (!is_micro_task_queued) {
      is_micro_task_queued = true;
      queueMicrotask(process_microtask);
    }
  }
  var effect2 = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags = effect2.f;
    if ((flags & BRANCH_EFFECT) !== 0) {
      if ((flags & CLEAN) === 0)
        return;
      set_signal_status(effect2, MAYBE_DIRTY);
    }
  }
  current_queued_root_effects.push(effect2);
}
function recursively_process_effects(effect2, filter_flags, shallow, collected_user) {
  var current_child = effect2.first;
  var user = [];
  while (current_child !== null) {
    var child = current_child;
    current_child = child.next;
    var flags = child.f;
    var is_inactive = (flags & (DESTROYED | INERT)) !== 0;
    if (is_inactive)
      continue;
    var is_branch = flags & BRANCH_EFFECT;
    var is_clean = (flags & CLEAN) !== 0;
    if (is_branch) {
      if (is_clean)
        continue;
      set_signal_status(child, CLEAN);
    }
    if ((flags & RENDER_EFFECT) !== 0) {
      if (is_branch) {
        if (shallow)
          continue;
        recursively_process_effects(child, filter_flags, false, collected_user);
      } else {
        if (check_dirtiness(child)) {
          execute_effect(child);
        }
        recursively_process_effects(child, filter_flags, false, collected_user);
      }
    } else if ((flags & EFFECT) !== 0) {
      if (is_branch || is_clean) {
        if (shallow)
          continue;
        recursively_process_effects(child, filter_flags, false, collected_user);
      } else {
        user.push(child);
      }
    }
  }
  if (user.length > 0) {
    if ((filter_flags & EFFECT) !== 0) {
      collected_user.push(...user);
    }
    if (!shallow) {
      for (var i = 0; i < user.length; i++) {
        recursively_process_effects(user[i], filter_flags, false, collected_user);
      }
    }
  }
}
function flush_nested_effects(effect2, filter_flags, shallow = false) {
  var user_effects = [];
  var previously_flushing_effect = is_flushing_effect;
  is_flushing_effect = true;
  try {
    if (effect2.first === null && (effect2.f & BRANCH_EFFECT) === 0) {
      flush_queued_effects([effect2]);
    } else {
      recursively_process_effects(effect2, filter_flags, shallow, user_effects);
      flush_queued_effects(user_effects);
    }
  } finally {
    is_flushing_effect = previously_flushing_effect;
  }
}
function flush_sync(fn, flush_previous = true) {
  var previous_scheduler_mode = current_scheduler_mode;
  var previous_queued_root_effects = current_queued_root_effects;
  try {
    infinite_loop_guard();
    const root_effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_root_effects = root_effects;
    if (flush_previous) {
      flush_queued_root_effects(previous_queued_root_effects);
    }
    var result = fn == null ? void 0 : fn();
    if (current_queued_root_effects.length > 0 || root_effects.length > 0) {
      flush_sync();
    }
    flush_tasks();
    flush_count = 0;
    return result;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_root_effects = previous_queued_root_effects;
  }
}
async function tick() {
  await Promise.resolve();
  flush_sync();
}
function get(signal) {
  if (DEV && signal.inspect && inspect_fn) {
    signal.inspect.add(inspect_fn);
    inspect_captured_signals.push(signal);
  }
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (is_signals_recorded) {
    captured_signals.add(signal);
  }
  if (current_reaction !== null && (current_reaction.f & BRANCH_EFFECT) === 0 && !current_untracking) {
    const unowned = (current_reaction.f & UNOWNED) !== 0;
    const dependencies = current_reaction.deps;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect);
    }
  }
  if ((flags & DERIVED) !== 0 && check_dirtiness(
    /** @type {import('#client').Derived} */
    signal
  )) {
    if (DEV) {
      const previous_inspect_fn = inspect_fn;
      inspect_fn = null;
      update_derived(
        /** @type {import('./types.js').Derived} **/
        signal,
        false
      );
      inspect_fn = previous_inspect_fn;
    } else {
      update_derived(
        /** @type {import('./types.js').Derived} **/
        signal,
        false
      );
    }
  }
  return signal.v;
}
function mark_reactions(signal, to_status, force_schedule) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    if ((!force_schedule || !runes) && reaction === current_effect) {
      continue;
    }
    var flags = reaction.f;
    set_signal_status(reaction, to_status);
    var maybe_dirty = (flags & MAYBE_DIRTY) !== 0;
    var unowned = (flags & UNOWNED) !== 0;
    if ((flags & CLEAN) !== 0 || maybe_dirty && unowned) {
      if ((reaction.f & DERIVED) !== 0) {
        mark_reactions(
          /** @type {import('#client').Derived} */
          reaction,
          MAYBE_DIRTY,
          force_schedule
        );
      } else {
        schedule_effect(
          /** @type {import('#client').Effect} */
          reaction
        );
      }
    }
  }
}
function untrack(fn) {
  const previous_untracking = current_untracking;
  try {
    current_untracking = true;
    return fn();
  } finally {
    current_untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function getContext(key) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key)
  );
  if (DEV) {
    const fn = current_component_context == null ? void 0 : current_component_context.function;
    if (fn) {
      add_owner(result, fn);
    }
  }
  return result;
}
function setContext(key, context) {
  const context_map = get_or_init_context_map();
  context_map.set(key, context);
  return context;
}
function hasContext(key) {
  const context_map = get_or_init_context_map();
  return context_map.has(key);
}
function getAllContexts() {
  const context_map = get_or_init_context_map();
  if (DEV) {
    const fn = current_component_context == null ? void 0 : current_component_context.function;
    if (fn) {
      for (const value of context_map.values()) {
        add_owner(value, fn);
      }
    }
  }
  return (
    /** @type {T} */
    context_map
  );
}
function get_or_init_context_map() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_CONTEXT" + (DEV ? "Context can only be used during component initialisation." : "")
    );
  }
  return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
function get_parent_context(component_context) {
  let parent = component_context.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
function push(props, runes = false, fn) {
  current_component_context = {
    // exports (and props, if `accessors: true`)
    x: null,
    // context
    c: null,
    // effects
    e: null,
    // mounted
    m: false,
    // parent
    p: current_component_context,
    // signals
    d: null,
    // props
    s: props,
    // runes
    r: runes,
    // legacy $:
    l1: [],
    l2: source(false),
    // update_callbacks
    u: null
  };
  if (DEV) {
    current_component_context.function = fn;
  }
}
function pop(component) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (component !== void 0) {
      context_stack_item.x = component;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (let i = 0; i < effects.length; i++) {
        effect(effects[i]);
      }
    }
    current_component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
  return component || /** @type {T} */
  {};
}
if (DEV) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        get: () => {
          if (value !== void 0) {
            return value;
          }
          throw new Error(
            `The ${rune} rune is only available inside .svelte and .svelte.js/ts files`
          );
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value, immutable = true, owners) {
  if (typeof value === "object" && value != null && !is_frozen(value)) {
    if (STATE_SYMBOL in value) {
      const metadata = (
        /** @type {import('#client').ProxyMetadata<T>} */
        value[STATE_SYMBOL]
      );
      if (metadata.t === value || metadata.p === value) {
        if (DEV) {
          if (owners) {
            for (const owner of owners) {
              add_owner(value, owner);
            }
          } else {
            strip_owner(value);
          }
        }
        return metadata.p;
      }
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      const proxy2 = new Proxy(value, state_proxy_handler);
      define_property(value, STATE_SYMBOL, {
        value: (
          /** @type {import('#client').ProxyMetadata} */
          {
            s: /* @__PURE__ */ new Map(),
            v: source(0),
            a: is_array(value),
            i: immutable,
            p: proxy2,
            t: value
          }
        ),
        writable: true,
        enumerable: false
      });
      if (DEV) {
        value[STATE_SYMBOL].o = owners === void 0 ? current_component_context ? (
          // @ts-expect-error
          /* @__PURE__ */ new Set([current_component_context.function])
        ) : null : owners && new Set(owners);
      }
      return proxy2;
    }
  }
  return value;
}
function unwrap(value, already_unwrapped) {
  if (typeof value === "object" && value != null && STATE_SYMBOL in value) {
    const unwrapped = already_unwrapped.get(value);
    if (unwrapped !== void 0) {
      return unwrapped;
    }
    if (is_array(value)) {
      const array = [];
      already_unwrapped.set(value, array);
      for (const element of value) {
        array.push(unwrap(element, already_unwrapped));
      }
      return array;
    } else {
      const obj = {};
      const keys = Reflect.ownKeys(value);
      const descriptors = get_descriptors(value);
      already_unwrapped.set(value, obj);
      for (const key of keys) {
        if (key === STATE_SYMBOL)
          continue;
        if (descriptors[key].get) {
          define_property(obj, key, descriptors[key]);
        } else {
          const property = value[key];
          obj[key] = unwrap(property, already_unwrapped);
        }
      }
      return obj;
    }
  }
  return value;
}
function unstate(value) {
  return (
    /** @type {T} */
    unwrap(
      /** @type {import('#client').ProxyStateObject} */
      value,
      /* @__PURE__ */ new Map()
    )
  );
}
function update_version(signal, d = 1) {
  set(signal, signal.v + d);
}
var state_proxy_handler = {
  defineProperty(target, prop, descriptor) {
    if (descriptor.value) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop);
      if (s !== void 0)
        set(s, proxy(descriptor.value, metadata.i, metadata.o));
    }
    return Reflect.defineProperty(target, prop, descriptor);
  },
  deleteProperty(target, prop) {
    const metadata = target[STATE_SYMBOL];
    const s = metadata.s.get(prop);
    const is_array2 = metadata.a;
    const boolean = delete target[prop];
    if (is_array2 && boolean) {
      const ls = metadata.s.get("length");
      const length = target.length - 1;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    if (s !== void 0)
      set(s, UNINITIALIZED);
    if (boolean) {
      update_version(metadata.v);
    }
    return boolean;
  },
  get(target, prop, receiver) {
    var _a;
    if (prop === STATE_SYMBOL) {
      return Reflect.get(target, STATE_SYMBOL);
    }
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop);
    if (s === void 0 && (effect_active() || updating_derived) && (!(prop in target) || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable))) {
      s = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata.o));
      metadata.s.set(prop, s);
    }
    if (s !== void 0) {
      const value = get(s);
      return value === UNINITIALIZED ? void 0 : value;
    }
    if (DEV) {
      if (typeof target[prop] === "function" && prop !== Symbol.iterator) {
        return batch_inspect(target, prop, receiver);
      }
    }
    return Reflect.get(target, prop, receiver);
  },
  getOwnPropertyDescriptor(target, prop) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
    if (descriptor && "value" in descriptor) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop);
      if (s) {
        descriptor.value = get(s);
      }
    }
    return descriptor;
  },
  has(target, prop) {
    var _a;
    if (prop === STATE_SYMBOL) {
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const has = Reflect.has(target, prop);
    let s = metadata.s.get(prop);
    if (s !== void 0 || effect_active() && (!has || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable))) {
      if (s === void 0) {
        s = (metadata.i ? source : mutable_source)(
          has ? proxy(target[prop], metadata.i, metadata.o) : UNINITIALIZED
        );
        metadata.s.set(prop, s);
      }
      const value = get(s);
      if (value === UNINITIALIZED) {
        return false;
      }
    }
    return has;
  },
  set(target, prop, value, receiver) {
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop);
    if (s === void 0 && effect_active()) {
      untrack(() => receiver[prop]);
      s = metadata.s.get(prop);
    }
    if (s !== void 0) {
      set(s, proxy(value, metadata.i, metadata.o));
    }
    const is_array2 = metadata.a;
    const not_has = !(prop in target);
    if (DEV) {
      if (metadata.o) {
        check_ownership(metadata.o);
        for (const owner in metadata.o) {
          add_owner(value, owner);
        }
      } else {
        strip_owner(value);
      }
    }
    if (is_array2 && prop === "length") {
      for (let i = value; i < target.length; i += 1) {
        const s2 = metadata.s.get(i + "");
        if (s2 !== void 0)
          set(s2, UNINITIALIZED);
      }
    }
    target[prop] = value;
    if (not_has) {
      if (is_array2) {
        const ls = metadata.s.get("length");
        const length = target.length;
        if (ls !== void 0 && ls.v !== length) {
          set(ls, length);
        }
      }
      update_version(metadata.v);
    }
    return true;
  },
  ownKeys(target) {
    const metadata = target[STATE_SYMBOL];
    get(metadata.v);
    return Reflect.ownKeys(target);
  }
};
if (DEV) {
  state_proxy_handler.setPrototypeOf = () => {
    throw new Error("Cannot set prototype of $state object");
  };
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_nodes = (
  /** @type {any} */
  null
);
function set_hydrate_nodes(nodes) {
  hydrate_nodes = nodes;
}
function hydrate_anchor(node) {
  if (node.nodeType !== 8) {
    return node;
  }
  var current = (
    /** @type {Node | null} */
    node
  );
  if (
    /** @type {Comment} */
    (current == null ? void 0 : current.data) !== HYDRATION_START
  ) {
    return node;
  }
  var nodes = [];
  var depth = 0;
  while ((current = /** @type {Node} */
  current.nextSibling) !== null) {
    if (current.nodeType === 8) {
      var data = (
        /** @type {Comment} */
        current.data
      );
      if (data === HYDRATION_START) {
        depth += 1;
      } else if (data === HYDRATION_END) {
        if (depth === 0) {
          hydrate_nodes = /** @type {import('#client').TemplateNode[]} */
          nodes;
          return current;
        }
        depth -= 1;
      }
    }
    nodes.push(current);
  }
  throw new Error("Expected a closing hydration marker");
}

// node_modules/svelte/src/internal/client/dom/operations.js
var node_prototype;
var element_prototype;
var text_prototype;
var append_child_method;
var clone_node_method;
var first_child_get;
var next_sibling_get;
var text_content_set;
var class_name_set;
var $window;
var $document;
function init_operations() {
  if (node_prototype !== void 0) {
    return;
  }
  node_prototype = Node.prototype;
  element_prototype = Element.prototype;
  text_prototype = Text.prototype;
  append_child_method = node_prototype.appendChild;
  clone_node_method = node_prototype.cloneNode;
  $window = window;
  $document = document;
  element_prototype.__click = void 0;
  text_prototype.__nodeValue = " ";
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  first_child_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "firstChild").get;
  next_sibling_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "nextSibling").get;
  text_content_set = /** @type {(this: Node, text: string ) => void} */
  // @ts-ignore
  get_descriptor(node_prototype, "textContent").set;
  class_name_set = /** @type {(this: Element, class_name: string) => void} */
  // @ts-ignore
  get_descriptor(element_prototype, "className").set;
}
function clone_node(node, deep) {
  return (
    /** @type {N} */
    clone_node_method.call(node, deep)
  );
}
function empty() {
  return document.createTextNode("");
}
function clear_text_content(node) {
  text_content_set.call(node, "");
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
function handle_event_propagation(handler_element, event) {
  var _a;
  var owner_document = handler_element.ownerDocument;
  var event_name = event.type;
  var path = ((_a = event.composedPath) == null ? void 0 : _a.call(event)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event.target
  );
  if (event.target !== current_target) {
    define_property(event, "target", {
      configurable: true,
      value: current_target
    });
  }
  var path_idx = 0;
  var handled_at = event.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx + 1;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event.target;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  while (current_target !== null) {
    var parent_element = current_target.parentNode || /** @type {any} */
    current_target.host || null;
    var internal_prop_name = "__" + event_name;
    var delegated = current_target[internal_prop_name];
    if (delegated !== void 0 && !/** @type {any} */
    current_target.disabled) {
      if (is_array(delegated)) {
        var [fn, ...data] = delegated;
        fn.apply(current_target, [event, ...data]);
      } else {
        delegated.call(current_target, event);
      }
    }
    if (event.cancelBubble || parent_element === handler_element || current_target === handler_element) {
      break;
    }
    current_target = parent_element;
  }
  event.__root = handler_element;
  current_target = handler_element;
}

// node_modules/svelte/src/internal/client/render.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var should_intro = true;
function mount(component, options) {
  const anchor = options.target.appendChild(empty());
  return flush_sync(() => _mount(component, { ...options, anchor }), false);
}
function hydrate(component, options) {
  const target = options.target;
  const previous_hydrate_nodes = hydrate_nodes;
  let hydrated = false;
  try {
    return flush_sync(() => {
      set_hydrating(true);
      var node = target.firstChild;
      while (node && (node.nodeType !== 8 || /** @type {Comment} */
      node.data !== HYDRATION_START)) {
        node = node.nextSibling;
      }
      if (!node) {
        throw new Error("Missing hydration marker");
      }
      const anchor = hydrate_anchor(node);
      const instance = _mount(component, { ...options, anchor });
      set_hydrating(false);
      hydrated = true;
      return instance;
    }, false);
  } catch (error) {
    if (!hydrated && options.recover !== false) {
      console.error(
        "ERR_SVELTE_HYDRATION_MISMATCH" + (DEV ? ": Hydration failed because the initial UI does not match what was rendered on the server." : ""),
        error
      );
      clear_text_content(target);
      set_hydrating(false);
      return mount(component, options);
    } else {
      throw error;
    }
  } finally {
    set_hydrating(!!previous_hydrate_nodes);
    set_hydrate_nodes(previous_hydrate_nodes);
  }
}
function _mount(Component, { target, anchor, props = (
  /** @type {Props} */
  {}
), events, context, intro = false }) {
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const bound_event_listener = handle_event_propagation.bind(null, target);
  const bound_document_event_listener = handle_event_propagation.bind(null, document);
  const event_handle = (events2) => {
    for (let i = 0; i < events2.length; i++) {
      const event_name = events2[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        target.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
        document.addEventListener(
          event_name,
          bound_document_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  let component = void 0;
  const unmount2 = effect_root(() => {
    branch(() => {
      untrack(() => {
        if (context) {
          push({});
          var ctx = (
            /** @type {import('#client').ComponentContext} */
            current_component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        should_intro = intro;
        component = Component(anchor, props) || {};
        should_intro = true;
        if (context) {
          pop();
        }
      });
    });
    return () => {
      for (const event_name of registered_events) {
        target.removeEventListener(event_name, bound_event_listener);
      }
      root_event_handles.delete(event_handle);
    };
  });
  mounted_components.set(component, unmount2);
  return component;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component) {
  const fn = mounted_components.get(component);
  if (DEV && !fn) {
    console.warn("Tried to unmount a component that was not mounted.");
  }
  fn == null ? void 0 : fn();
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component,
        ...options
      });
    }
  };
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('svelte').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, {});
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance, void 0);
    const props = proxy({ ...options.props || {}, $$events: __privateGet(this, _events) }, false);
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      props,
      context: options.context,
      intro: options.intro,
      recover: options.recover
    }));
    for (const key of Object.keys(__privateGet(this, _instance))) {
      if (key === "$set" || key === "$destroy" || key === "$on")
        continue;
      define_property(this, key, {
        get() {
          return __privateGet(this, _instance)[key];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    __privateGet(this, _events)[event] = __privateGet(this, _events)[event] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event].push(cb);
    return () => {
      __privateGet(this, _events)[event] = __privateGet(this, _events)[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

export {
  is_array,
  object_keys,
  create_fragment_from_html,
  user_effect,
  render_effect,
  destroy_effect,
  unstate,
  current_effect,
  current_component_context,
  flush_sync,
  tick,
  untrack,
  getContext,
  setContext,
  hasContext,
  getAllContexts,
  hydrating,
  hydrate_nodes,
  clone_node,
  mount,
  hydrate,
  unmount,
  createClassComponent,
  asClassComponent
};
//# sourceMappingURL=chunk-KSCWJN2A.js.map
