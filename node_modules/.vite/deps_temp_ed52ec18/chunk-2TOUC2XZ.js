// node_modules/svelte/src/compiler/phases/1-parse/utils/names.js
var void_element_names = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return void_element_names.includes(name) || name.toLowerCase() === "!doctype";
}

// node_modules/svelte/src/internal/shared/validate.js
var snippet_symbol = Symbol.for("svelte.snippet");
function add_snippet_symbol(fn) {
  fn[snippet_symbol] = true;
  return fn;
}
function validate_snippet(snippet_fn) {
  if (snippet_fn && snippet_fn[snippet_symbol] !== true) {
    throw new Error(
      "The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`."
    );
  }
  return snippet_fn;
}
function validate_component(component_fn) {
  if ((component_fn == null ? void 0 : component_fn[snippet_symbol]) === true) {
    throw new Error("A snippet must be rendered with `{@render ...}`");
  }
  return component_fn;
}
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
  }
}

export {
  add_snippet_symbol,
  validate_snippet,
  validate_component,
  validate_void_dynamic_element,
  validate_dynamic_element_tag
};
//# sourceMappingURL=chunk-2TOUC2XZ.js.map
